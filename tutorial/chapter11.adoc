= 11. Разработка сложных классов с данными

В этом и следующем разделе мы поговорим о том, как разрабатываются сложные классы и зачем это вообще нужно.

Из раздела 8 мы уже знаем, что классы помогают нам структурировать данные и определять над ними различные законченные операции.
Около 30 лет назад программисты решили для себя, что при разработке программ **сложных** человеку проще отталкиваться от понятий,
участвующих в задаче, чем от действий, которые надо выполнить для её решения. 
Так зародилась парадигма объектно-ориентированного программирования (ООП).

Если мы используем ООП, то, решая задачу, мы думаем прежде всего о том, какие в ней фигурируют понятия (существительные),
и как эти понятия наиболее адекватно описать на языке программирования. 
Как правило, одному понятию исходной задачи ставится в соответствие один класс.
Какие именно понятия исходной задачи являются настолько важными, чтобы заслужить наличие отдельного класса в программе, определяет программист, исходя из своего опыта.

К примеру, представим себе, что мы пишем арифметический тренажёр для учеников средней школы, и этот тренажёр должен научить их делать элементарные операции с рациональными числами вида `P/Q`. В таком проекте важными понятиями будут являться "рациональное число" и "тренажёр".

Следующим шагом мы должны определить, что входит в каждый из этих классов. Класс состоит из данных, которые хранятся в каждом его объекте, и функций, работающих с этими данными, причём, как правило, данные становятся закрытыми `private`, а функции остаются открытыми. Подобный принцип называется __инкапсуляцией__ (см. также раздел 8.5). К примеру, для рационального числа данными (свойствами) являются числитель и знаменатель, а функциями -- сложение, вычитание, умножение и деление. Для тренажёра данными могут являться два рациональных числа, над которыми ученик должен выполнить операцию, и ожидаемый результат, а функциями -- случайная генерация этих чисел, проверка правильности результата ученика, подсчёт количества правильных ответов и так далее.

Рассмотрим подробнее проектирование класса "рациональное число". Первая идея, которая здесь приходит в голову -- описать данные класса следующим образом:

[source,kotlin]
----
// numerator = числитель, denominator = знаменатель
class Rational(val numerator: Int, val denominator: Int)
----

Попробуйте подумать сами, какая проблема может быть связана с этим представлением, прежде чем читать дальше.

Проблема становится понятна, как только мы попытаемся сопоставить числа `Rational(1, 2)` и `Rational(3, 6)` и, к примеру, сравнить их на равенство. Числа `1/2` и `3/6` очевидно равны друг другу, но очевидно это только человеку. Для того, чтобы в этом мог убедиться компьютер, необходимо сократить дробь `3/6`, разделив числитель и знаменатель на 3 и превратив её в `1/2`. Это означает, что внутри функции `equals` нам придётся выполнять такую операцию сокращения и, что ещё хуже, учитывать её при расчёте __хеш-кода__ (про него см. подробнее раздел 9). 

Гораздо проще выполнить сокращение сразу же, при создании рационального числа, а в функции `equals` осуществлять только сравнение числителя и знаменателя. Например:

[source,kotlin]
----
class Rational(numerator: Int, denominator: Int) : Comparable<Rational> {
    val numerator: Int
    val denominator: Int

    private tailrec fun gcd(a: Int, b: Int): Int =
        when {
            a == b || b == 0 -> a
            a == 0 -> b
            a > b -> gcd(a % b, b)
            else -> gcd(a, b % a)
        }

    init {
        if (denominator == 0) throw ArithmeticException("Denominator cannot be zero")
        var gcd = gcd(abs(numerator), abs(denominator))
        if (denominator < 0) gcd = -gcd
        this.numerator = numerator / gcd
        this.denominator = denominator / gcd
    }
    
    override fun equals(other: Any?) =
        when {
            this === other -> true
            other is Rational -> numerator == other.numerator && denominator == other.denominator
            else -> false
        }    
}
----

TODO: раздел находится в разработке.

== Упражнения

Откройте каталог `src/lesson11/task1` в проекте. Внутри находится файл с рассмотренным выше примером `Rational.kt`, а также пять других файлов с различными заданиями на проектирование классов с данными. Задания различаются по сложности; самое простое из них находится в файле `Complex.kt`, самое сложное -- в файле `UnsignedBigInteger.kt`. Суть каждого задания описана в заголовочном комментарии класса, плюс дан короткий комментарий к каждой функции класса.

Выберите одно из заданий, которое кажется вам посильным. Замените на реализацию все `TODO()`, которые есть в классе. После этого откройте тесты для данного класса из каталога `test/lesson11/task`. Подумайте над тем, какие из важных случаев рассмотрены тестами, а какие -- нет. Дополните тесты нерассмотренными случаями. После этого запустите тесты для вашего класса и добейтесь их полного прохождения.

При желании вы можете решить второе задание более высокой сложности. Далее переходите к уроку 12.
